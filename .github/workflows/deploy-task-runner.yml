name: deploy:task-runner

on:
  workflow_dispatch:
    inputs:
      workflow-run-id:
        description: 'The upstream workflow run id'
        required: true
      artifact-id:
        description: 'The artifact id to deploy'
        required: true
      tag:
        description: 'The tag of the artifact to deploy'
        required: true
        
jobs:     
  build:
    runs-on: ubuntu-latest  
    environment: ${{ github.ref_name }} # TODO
    outputs:
      image_version: ${{ fromJson(steps.docker-metadata.outputs.labels)['org.opencontainers.image.version'] }}
      image_ref: ${{ fromJson(steps.docker-metadata.outputs.tags)[0] }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            deployments/task-runner

      - name: Download artifact
        uses: actions/download-artifact@v4
        id: download-artifact
        with:
          github-token: ${{ secrets.ORG_TOKEN }}
          repository: ${{ vars.DEPLOYMENT_API_REPO }}
          name: ${{ github.event.inputs.artifact-id }}
          run-id: ${{ github.event.inputs.workflow-run-id }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker meta
        uses: docker/metadata-action@v5
        id: docker-metadata
        with:
          images: |
            ${{ vars.IMAGE_REGISTRY_URL_TASK_RUNNER }}
          tags: |
            type=raw,value={{sha}}-{{date 'X'}}

      - name: Build Docker image and export
        uses: docker/build-push-action@v6
        with:
          context: .
          tags: ${{ steps.docker-metadata.outputs.tags }}
          labels: ${{ steps.docker-metadata.outputs.labels }}
          push: false     
          file: deployments/api/Dockerfile 
          outputs: type=docker,dest=/tmp/${{ fromJson(steps.docker-metadata.outputs.labels)['org.opencontainers.image.version'] }}.tar

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ fromJson(steps.docker-metadata.outputs.labels)['org.opencontainers.image.version'] }}
          path: /tmp/${{ fromJson(steps.docker-metadata.outputs.labels)['org.opencontainers.image.version'] }}.tar

  trivy-scan:
    runs-on: ubuntu-latest
    needs: build
    steps:
    - name: Download image artifact
      uses: actions/download-artifact@v4
      with:
        name: ${{ needs.build.outputs.image_version }}
        path: /tmp

    - name: Load image
      run: |
        docker load --input /tmp/${{ needs.build.outputs.image_version }}.tar
        docker image ls -a  

    - name: Run trivy vulnerability scanner
      uses: aquasecurity/trivy-action@0.28.0
      env:
        TRIVY_DB_REPOSITORY: "public.ecr.aws/aquasecurity/trivy-db:2"        
      with:
        image-ref: ${{ needs.build.outputs.image_ref }}
        format: 'table'
        exit-code: '1'
        ignore-unfixed: false
        vuln-type: 'os,library'
        severity: 'CRITICAL,HIGH'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'

  create-revision:  
    runs-on: ubuntu-latest
    needs: [build, trivy-scan]
    outputs:
      task_def_arn: ${{ steps.create-task-def.outputs.task_def_arn}}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_DEFAULT_REGION }}

      - name: Login to ECR
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.IMAGE_REGISTRY_URL_TASK_RUNNER }}

      - name: "Push to ECR"
        run: |
          docker push ${{ needs.build.outputs.image_ref }}

      - name: Update the task-definition
        id: create-task-def
        run: |
          NEW_IMAGE=${{ needs.build.outputs.image_ref }}
          TASK_FAMILY=${{ vars.TASK_DEF_FAMILY_TASK_RUNNER }}
          CONTAINER_NAME_TASK_RUNNER=${{ vars.CONTAINER_NAME_TASK_RUNNER }}

          # Fetch the latest task definition
          LATEST_TASK_DEF=$(aws ecs describe-task-definition --task-definition "$TASK_FAMILY")

          # Extract necessary fields
          CONTAINER_DEFINITIONS=$(echo "$LATEST_TASK_DEF" | jq ".taskDefinition.containerDefinitions")
          TASK_ROLE_ARN=$(echo "$LATEST_TASK_DEF" | jq -r ".taskDefinition.taskRoleArn")
          EXECUTION_ROLE_ARN=$(echo "$LATEST_TASK_DEF" | jq -r ".taskDefinition.executionRoleArn")
          NETWORK_MODE=$(echo "$LATEST_TASK_DEF" | jq -r ".taskDefinition.networkMode")
          COMPATIBILITIES=$(echo "$LATEST_TASK_DEF" | jq -r ".taskDefinition.compatibilities")
          CPU=$(echo "$LATEST_TASK_DEF" | jq -r ".taskDefinition.cpu")
          MEMORY=$(echo "$LATEST_TASK_DEF" | jq -r ".taskDefinition.memory")

          # Update the container image
          UPDATED_CONTAINER_DEFINITIONS=$(echo "$CONTAINER_DEFINITIONS" | jq -c --arg cn "$CONTAINER_NAME_TASK_RUNNER" --arg ni "$NEW_IMAGE" 'map(if .name == $cn then .image = $ni else . end)')

          # Save updated container definitions to a file
          CONTAINER_DEFINITIONS_FILE="container-definitions.json"
          echo "$UPDATED_CONTAINER_DEFINITIONS" > "$CONTAINER_DEFINITIONS_FILE"

          # Register the new task definition
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --family "$TASK_FAMILY" \
            --task-role-arn "$TASK_ROLE_ARN" \
            --execution-role-arn "$EXECUTION_ROLE_ARN" \
            --network-mode "$NETWORK_MODE" \
            --requires-compatibilities "$COMPATIBILITIES" \
            --cpu "$CPU" \
            --memory "$MEMORY" \
            --container-definitions file://"$CONTAINER_DEFINITIONS_FILE" \
            --query "taskDefinition.taskDefinitionArn" \
            --output text)
          
          echo "task_def_arn=$NEW_TASK_DEF_ARN" >> "$GITHUB_OUTPUT"
  deploy:
    runs-on: ubuntu-latest
    needs: [create-revision]
    steps:
      - name: Update ECS Service Revision
        run: |     
          NEW_TASK_DEF_ARN=$(aws ecs update-service \
            --cluster ${{ vars.ECS_CLUSTER_NAME }} \
            --service ${{ vars.ECS_SERVICE_NAME }} \
            --task-definition ${{ needs.create-revision.outputs.task_def_arn }} \
            --query "service.taskDefinition" \
            --output text)

          echo "Deployed new service revision: $NEW_TASK_DEF_ARN"

